---
title: "Aula 02 - O que é R?"
author: "Frederico Bertholini"
subtitle: "Métodos Quantitativos Aplicados à Ciência Política"
format: 
    revealjs:
      self-contained: true
      touch: true
      lang: pt-BR
      toc: true
      toc-depth: 1
    #  theme: moon
     # footer: CURSO DE R
    #  logo: imgs/logo.png

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T,eval=T)
```


# Abrindo o R e conhecendo o software

## Passos iniciais

  - R é software de **PROGRAMAÇÃO ESTATÍSTICA**
  
:::{.callout-note}
Tem dividido com o Python o posto de software mais popular entre cientistas sociais   
:::

  - Vantagens:  
    -- Software Livre   
    -- Documentação completa e acessível  
    -- Diversidade de arquivos  
    -- Replicabilidade de rotinas


## Um Excel que usou o suco?

  - Se é possível fazer no Excel, é possível fazer no R
  - Entretanto, se é possível fazer no R, não necessariamente é possível fazer no Excel

Ambiente de desenvolvimento para cálculos estatísticos e gráficos

Vários cálculos estatísticos mais sofisticados estão disponíveis no R através de pacotes desenvolvidos pela comunidade

## Habilidades necessárias

Escrita:  
  -- Elementos (ex: `numeric, character, factor`...);  
  -- Funções básicas (ex: `sum(), table(), sd()`);  
  -- Composição do script (ex: `c(), for loop`);  

Leitura:  
  -- Identificação de funções;  
  -- Diferentes soluções;  
  -- Alertas de erros;

:::{.callout-important}
adquirir **autonomia** com o software
:::

## Habilidade mais importante 

Dada a multiplicidade de soluções, de alertas de erros e o universo de pacotes com diversas funções

**`a habilidade mais importante é saber pesquisar no Google`**  

Melhor em inglês pela quantidade de fóruns:  
  
  -- Melhor fórum: [Stackoverflow](https://stackoverflow.com/)
  
  -- [Posit Community](https://community.rstudio.com/) despontando

:::{.callout-tip}
IA como nova 'habilidade': além do ChatGPT
:::


## RStudio

  - RStudio é um ambiente para desenvolvimento do R (IDE)
  - Ao longo do curso utilizaremos o RStudio  
  - Utilizando nada dos botões ou possibilidades específicas do RStudio  

>> Posit (<https://posit.co/download/rstudio-desktop/>)

[Posit Cloud for free](https://posit.cloud/)

## Aparência do RStudio

![Aparência](imgs/1.png)


## Básico do básico: um operador e um comando

Linhas escritas no ambiente onde se registra o script (Scripts são arquivos de texto)

Ctrl + enter (cmd + enter no mac)

  - Executa (roda) as funções e programações escritas nas linhas selecionadas  
  
Hastags  

  - Insere comentários sem gerar outputs (organizar e registrar dentro dos scripts)  


Fluxos: scripts e projetos

## Como sai no R?

```{r,eval=F}
#Insere comentarios sem rodar o comando

Importante para organizar e

# Erro: unexpected symbol in "Importante para"

##Registrar o que se vai fazer ou foi feito

```


## R como calculadora

  - Um função primordial e básica do R, como software estatístico, é de calculadora
  - O R possui os operadores básicos da matemática como '+' , '-', '*' e '/'

```{r}
5 + 5

5 - 3

4 * 9

16 / 2

```
    


## R como calculadora

  - Assim como na matemática, atenção em relação aos ()
  
```{r}
(5 + 6) * 3

5 + 6 * 3
```
  - Além das funções de exponencial e raiz quadrada
  
  - Respectivamente, ^ e sqrt()
  
```{r}
2 ^ 2

sqrt(36)
```
   


## Lógica

  - O R permite também avaliações lógicas
  - Ou seja, o software possui operadores lógicos afim de fazer testes lógicos com resultados de Verdadeiro ou Falso de acordo com a proposição
  - Os principais operadores são $==$, $<$ , $>$, $<=$ , $>=$ e $!=$
```{r}
5 == 5

5 <= 5 / 5

5 * 4 > 5

3 != 6
```
    


## Lógica

  - Testamos também Verdade e Falsidade
```{r}
TRUE == TRUE

TRUE <= FALSE
```
  - Assim como estamos caracteres
```{r}
"Python" == "python"

"Stata" != "Sasta"

```



## Operadores lógicos especiais

  - Atenção para os operadores e e ou
  - O primeiro, para ser verdade, precisa que todos os pressupostos sejam verdadeiros
```{r}
(3 == 3) & (4 != 5)
```
  - O ou, por sua vez, para ser verdade precisa que apenas 1 pressuposto seja verdadeiro
```{r}
(3 != 3) | (4 != 5)
```
    


## Atribuição

  - Trata-se da famosa 'setinha' que indica objetos (valores, vetores, dataframes) para alguma etiqueta
  - Dessa maneira, podemos 'salvar' os objetos nas etiquetas para utilizarmos através dessas em qualquer momento ao longo do script
  - Quando utilizadas em operações, as etiquetas representam aquilo que fora atribuído a elas
  - Quando criamos a etiqueta, não geramos outputs, apenas quando rodamos diretamente a etiqueta
  
```{r}
sorte <- 5
```



## Regras do uso da setinha

  - Atenção, letras maiúsculas e minúsculas importam

```{r,eval=F}
sorte <- 5

Sorte

# Erro: objeto 'Sorte' não encontrado

```

## Regras do uso da setinha
  - Também não podemos criar etiquetas que começam com números
```{r,eval=F}

15luck <- 15

# Erro: unexpected symbol in "15luck"

```

Cuidado com a utilização de etiquetas com o mesmo nome de funções, pode gerar confusão no script


## Classes

Em basicamente tudo que iremos fazer no R, a classe da informação importa
Em termos elementares, ou ao nível dos valores, existem três grandes classes:  
  - Numeric (númerico);  
  - Logical (lógico);  
  - Character ou factor (caracteres);
  
**Para obter a informação sobre a classe, iremos aprender nossa primeira função no R: class()**
    

## Númerico

  - `numeric` é a classe composta por valores númericos
```{r}
class(sorte)

```
  - Objetos deste tipo permitem funções matemáticas como média, mediana etc...
  
## Númerico 
  - No caso de valores decimais, utilizamos ponto em vez de vírgula
```{r, eval=F}
decimal <- 3,5

# Erro: ',' inesperado in "decimal <- 3,"

decimal <- 3.5


```
    


## Lógico

  - `logical` é a classe composta por TRUE, FALSE e NA
  
```{r}
vdd <- TRUE

class(vdd)

```
  
  - Não é preciso escrever sempre TRUE e FALSE, podemos resumir para T e F, respectivamente
  
  - Por trás dos valores T e F, há valores númericos correspondente a 1 e 0
  
```{r}
T + F

```


## Caracteres

  - `character` é a classe composta por nomes
  
  - Importante característica é que os nomes devem estar dentro de aspas, caso contrário, o R não reconhecerá como caracter
  
```{r}
nome <- "Alvaro"

nome

class(nome)

```
    


## Caracteres vs Fatores

  - Em termos estatísticos, não há diferença entre caracteres e fatores
  - Fatores apresentam as categorias por dentro de vetor.
  - Em termos de manipulação de dataframes, porém, veremos que esses dois objetos terão tratamento distintos, a começar pela importação da base e a definição de string tratada como factor
    


# Vetores

## O que são vetores?
 
  - Vetores são combinações de valores em uma estrutura unidimensional 
  - Ou seja, podem ser combinações de números, valores lógicos, nomes e várias outras possibilidades
  - Por exemplo, combinação de valores pares: 2,4,6,8
  - Ou a combinações de nomes começando por P: Pedro, Paula, Pietro, Paloma
  - Combinação de valores lógico: TRUE, FALSE, TRUE, TRUE
 
 
## Criação de vetores
 
  - Para criar vetores é importante combinar valores
  - A função necessária para a criação de vetores é a função c(), c de *combine* ou *concatenate*
```{r}
c(2,4,6,8)

c("Pedro","Paula","Pietro","Paloma")

c(TRUE,FALSE,TRUE,FALSE)
``` 
  
 
## Etiquetas para vetores
 
  - Assim como fizemos com os valores, atribuímos também etiquetas aos vetores
  - Dessa maneira, podemos trabalhar com as sequências ao longo do script, assim como dar razão ou justificativa aos valores combinados
```{r}
n.pares <- c(2,4,6,8)

nomes.com.p <- 
c("Pedro","Paula","Pietro","Paloma") 

valores.log <- c(TRUE,FALSE,TRUE,FALSE)
``` 
  
 
## Classes dos vetores
 
  - Os vetores também possuem classes
  - Essas categorias determinam as operações possíveis dentro de um vetor
  - Para obter a informação sobre a classe de um vetor, utilizamos a função class()
```{r}
class(n.pares)

class(nomes.com.p)

class(valores.log)
``` 
  
 

## Comprimento de vetores
 
  - Os vetores podem ser medidos em relação ao seu comprimento
  - O seu comprimento define a extensão do vetor, assim como quantos elementos estão presentes dentro da combinação de valores
  - O comprimento pode ser medido pela função length()
```{r}
length(n.pares)

length(nomes.com.p)

length(valores.log)
``` 
 
 
 

## Somatório de vetores
 
  - Para vetores númerico podemos somar os valores de um vetor
  - A função se chama sum() que corresponde ao $\sum$
```{r}
sum(n.pares)

``` 
  - Em vetores com valores lógicos, com TRUE e FALSE, o sum soma o número de T que temos dentro de um vetor

```{r}
sum(valores.log)

``` 

 
## Somatório de vetores
 
  - A função sum() pode se tornar ainda um contador de um teste
  - Por exemplo, queremos saber quantos nomes são iguais ao de Pedro no vetor 'nomes.com.p'
```{r}
teste1 <- nomes.com.p == "Pedro"

sum(teste1)

teste1
``` 
 

## Seleção de elementos
 
  - Queremos selecionar no vetor nomes.com.p o segundo elemento que é Paula
  - Vejamos, primeiro, como se compõe o vetor de caracteres nomes.com.p e a lógica do posicionamento dentro do vetor
```{r}
nomes.com.p
``` 

 

## Seleção de elementos
 
  - Vamos testar se Paula se inclui dentro do vetor sem termos que ver no console
  - As vezes, vetores são maiores do que temos como exemplo
  - Para o teste lógico, utilizamos o operador %in%, que retorna TRUE, caso o valor esteja incluso no vetor
```{r}
"Paula" %in% nomes.com.p
``` 
 


## Seleção de elementos
 
  - Algumas operações se restrigem a determinados elementos ou a um conjunto deles incluso dentro de um vetor
  - Para realizar tais procedimentos precisamos saber escolher elementos
  - Para isso, utilizaremos o operador '[]' depois de apontar o vetor
  - Mais especificamente: 
 Vetor; 
 []; 
 Posição ou regra; 
 
 

## Seleção de elementos
 
  - Para escolhar Paula, portanto, vamos definir como a segunda posição dentro do vetor
```{r}
nomes.com.p[2]
``` 
  - O posicionamento dos nomes ao longo do vetor determina como seleciona-lo individualmente
  - Porém, podemos selecionar através do valor
```{r}
nomes.com.p[nomes.com.p == "Paula"]
``` 
 
 
## Seleção de elementos
 
  - Selecionamos também o último valor do vetor nomes.com.p
  - Sabemos que o vetor possui 4 valores utilizando a função length()
```{r}
length(nomes.com.p)
``` 

## Seleção de elementos
  - Assim o último valor é igual a 4
  - Para selecionarmos o último valor, ou definimos como a posição 4 ou apenas o length() do vetor
```{r}
nomes.com.p[4]

nomes.com.p[length(nomes.com.p)]

``` 
 
 
## Seleção de elementos
 
  - Para seleção de elementos através de regras, podemos utilizar o vetor númerico de n.pares
```{r}
n.pares  <- c(2,4,6,8)

n.pares

``` 
  - O objetivo aqui é selecionar os elementos maiores que 5, que é a mediana do vetor
```{r}
median(n.pares)

``` 
 
 

## Seleção de elementos
 
  - Selecionamos, assim, os elementos acima da mediana do vetor n.pares, que são os valores 6 e 8
```{r}
n.pares[n.pares > 5]
``` 
  - Ou ainda podemos definir o valor 5 como o valor da mediana
  - O resultado é o mesmo, porém, deixa claro ao leitor do seu script que se trata dos valores acima da mediana do vetor n.pares
```{r}
n.pares[n.pares > median(n.pares)]
``` 

# Operações matemáticas

## Operações com vetores
  - Em vetores numéricos, podemos fazer operações matemáticas a partir do seu posicionamento
  - Vamos calcular o alcance do vetor "n.pares"
```{r}
#ultimo elemento 
n.pares[length(n.pares)]

#primeiro elemento
n.pares[1]

``` 
  - Subtraindo esses dois elementos, temos o alcance do vetor
```{r}
n.pares[length(n.pares)] - n.pares[1]

``` 


## Operações com vetores
 
  - Ainda em vetores numéricos, vamos calcular vetores com regras
  - Selecionamos elementos maiores que 5
```{r}
n.pares[n.pares >= 5]

``` 
  - Queremos duplicar os valores inclusos dentro da condição
```{r}
n.pares[n.pares >= 5] * 2

``` 
  - Por fim, operacionar um conjunto com um elemento
```{r}
n.pares[n.pares >= 5] * n.pares[1]

``` 
 

## Conjuntos
 
  - Utilizamos a teoria de conjuntos no R com a função de manipular e identificar elementos comuns ou diferente entre vetores
  - Já temos o vetor "n.pares" e vamos criar um vetor com números naturais
```{r}
n.naturais <- c(0,1,2,3,4,5,6,7,8,9)
n.naturais

``` 
  - Se perguntarmos por valores que não estão no vetor "n.naturais", o resultado será conjunto vazio
```{r}
n.naturais[n.naturais == 10]
``` 
 
 

## Conjuntos
 
  - Outro ponto importante é saber se os elementos estão contidos dentro de outro vetor
  - A pergunta a se fazer é: os elementos do vetor "n.partidos" está contido no vetor "n.naturais"
  - No R, contidos é igual a \%in\%
```{r}
n.pares %in% n.naturais

``` 

## Conjuntos

  - Isto é, o vetor "n.pares" está contido no vetor "n.naturais" e é um subconjunto
  - Outra maneira é utilizando a função is.element()
```{r}
is.element(n.pares,n.naturais)

``` 
 
 
## Conjuntos
 
  - Para encontrar os valores exclusivos de um conjunto, vamos utilizar a escrita da seleção de elementos
  - Podemos incluir a notação de "!", que quer dizer diferente
  - Portanto, selecionamos os valores que estão contido no conjunto dos naturais, porém não no conjunto dos valores pares
```{r}
n.naturais[!is.element(n.naturais,n.pares)]

``` 
 

## Conjuntos
 
  - Por fim, vamos testar se um valor está presente em um desses vetores
  - Testaremos os valores 1, 11 e 21
```{r}
1 %in% c(n.naturais,n.pares)

11 %in% c(n.naturais,n.pares)

21 %in% c(n.naturais,n.pares)
``` 
  - Assim, não temos os valores 11 e 21 em nenhum dos vetores, entendidos como conjuntos 
 
 
# data.frame

## data.frame
 
  - Um `data.frame` é o mesmo que uma tabela do SQL ou uma planilha Excel
  
  - seus dados provavelmente serão importados para um objeto data.frame 

  - data.frame’s são listas especiais em que todos os elementos possuem o mesmo comprimento.

  - Cada elemento dessa lista pode ser pensado como uma coluna da tabela - ou como uma variável. Uso do '$'

  - Seu comprimento representa o número de linhas - ou seja, de observações


## Estrutura de dados - data.frame

![](imgs/dados.png)


## data.frame de perto

  - Como data.frames's são listas, suas colunas podem ser de classes diferentes. Essa é a grande diferença entre data.frame’s e matrizes.

Funções úteis:
```{r,eval=F} 
head() # Mostra as primeiras 6 linhas.
tail() # Mostra as últimas 6 linhas.
dim() # Número de linhas e de colunas.
names() # Os nomes das colunas (variáveis).
str() # Estrutura do data.frame. Mostra, entre outras coisas, as >classes de cada coluna.
cbind() # Acopla duas tabelas lado a lado.
rbind() # Empilha duas tabelas.
```  


